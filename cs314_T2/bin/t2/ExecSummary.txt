The Daemon Koders
March 5, 2008
Team Assignment 2
Class Testing the Cave Game

Executive Summary
Testing Approach	
	Our testing approach primarily involved creating various cave game elements that the JUnit test classes could use in order to assure that the methods used in the actual cave game worked properly.  For each JUnit class, we created the elements that are involved in each of the appropriate methods.  As an example, the JUnit class DoorTest tests only one cave game method, enter( ).  This class tests to see if a player can go through a door with a key, tests to see if that player can also go through the door without a key, and then tests to see if a player can go through a door with the wrong key.  In the cave game, doors only exist if there is a key needed to go in between two rooms.  Additional code was created during the set up if this class.  A key, a door, two test rooms that the door is attached to, and a player were all created as mock data to test these methods.  The methods, all variations of testing the door method enter( ), used this mock data to determine if the method was working correctly.  We repeated this same method for all of the other JUnit classes, and it was very helpful in determining if the methods used in the cave game worked. 
	Unfortunately, our original testing approach failed.  We wanted to simply use elements that were already created by the cave game when running and playing the game itself.  This would have been nice because it would have allowed for less coding.  However, we found it difficult to gain access to these items from the JUnit tests, and ultimately decided it was a good idea since we could not modify the original code – and that may have been the only way for us to get this to work.  It is probably a good thing that we could not get this to work, because by testing the methods the way we did, we could control the environment a lot easier and set up various specific scenarios when trying to find failures in any of the methods.
	Finally, the tools we used to complete this assignment were JUnit and EMMA.  JUnit was used  to test each specific method, and EMMA was used to report the coverage for each method in the JUnit classes.  EMMA will be discussed later in this summary.

Number of Tests Run in Test Categories
	Although the number of classes and methods that required to be tested were limited, it did not limit us in the amount of testing we did for each method.  As stated in our testing approach, we were able to set up environments that would allow each cave game method to be tested in various conditions.    By doing this, it allowed us to set up a variety of tests in each test category.  We are defining a category for the purpose of this summary as a specific class that is being tested.  The main categories we tested include the Door class, the Player class and the Room class.  
	For the Door class, we were to test the enter method.  The categories tested for the enter method were going through a door with a key, going through a door without a key, and going through a door with the wrong key.  We tested each of these sub-categories once.  
	In the Player class, we were required to test the go, pickUp and drop methods.  The go method was tested to see if the player would go to the room next to the room he was in correctly, and this was done once.  Next, the pickUp method was tested to see if the player could pick up items.  This was tested twice, as we tested picking up an item without having anything in his hands, and then picking up an item with an item already in his hands.  Finally, the drop method was tested similarly to the pickUp method tests.  We tested dropping item one and item two, therefore there were two drop tests.
	The last main category we tested was the Room class.  The methods to be tested were the addItem, removeItem, enter, and exit.  We tested the addItem method to see if the program could successfully add an item into the room.  We only tested this with one item.  The removeItem method was tested to see if we could remove an item already in the room.  This was tested once.  The enter method was tested one time, and it was only to see if the player could enter the next room.  Lastly, the exit method was tested twice.  It was tested to see if the player could exit the room.  One test involved exiting to an existing room, and the other involved exiting through a non-existent room.

Test Coverage
	As stated in our testing approach, we used EMMA to track the coverage of each test.  This means that by using EMMA to run a JUnit test, it will create a report showing exactly how many instructions were executed total and how many instructions were executed in a specific class, along with what percentage of the total instructions in each respective class were covered.  The reason why this is significant is because you want to be able to cover as much of a target class as possible, and the more methods that are covered, the higher the likelihood is to find failures in the program.  
	We used EclEmma, the Eclipse version of EMMA, in order to find test coverage within our tests.  After executing all tests, we found out that it was covering 42% of all the classes used in the package, and only 41% of all methods.  Our JUnit tests only ran through 5 out of 12 classes, and used 24 of the 59 total methods.  Although that may not seem like a lot, there are a lot of classes and methods in this program that do not affect the primary methods that were being tested.  Other statistics regarding this coverage include 28% (380/1375) of the blocks of code in the entire package, and also 26% (85.7/330) of the executable lines.  The full coverage report is available within this assignment submission in HTML form.

Failures

1. While testing the add item method from the room class we found that if you try and add a null item to the room it will not work.  We made a test and an object that was set to null.  When we tried to add the object the method failed.  This means that the method would not work for an item object that is null.  

